// Most of the the following was done by: Luke Schaeffer (https://dblp.org/pers/hd/s/Schaeffer:Luke)

#load("ostrowski/bco_valid.txt", "walnut", bco_lsd_valid(a, x))
#load("ostrowski/bco_leq.txt", "walnut", bco_leq(x, y))
#load("ostrowski/bco_adder.txt", "walnut", bco_adder(a, x, y, z))
#load("ostrowski/bco_finite_rep.txt", "walnut", bco_finite_rep(n))

Execute genFinite 3.
Execute genEqual 3.
Execute genZero 3.

Define fromBase3Pair x y :=
    match (x, y) with
    case (0, 0) => 0
    case (0, 1) => 1
    case (1, 0) => 2
    case (1, 1) => "NOT IN BASE 3"
    end.

Define fromBase3 xs ys := zipWith fromBase3Pair xs ys.

Define base3Format var reps :=
    match reps with
    case [(prefix1, cycle1), (prefix2, cycle2)] =>
        (var, concatenate (fromBase3 prefix1 prefix2) ^ "(" ^ concatenate (fromBase3 cycle1 cycle2) ^ ")^ω")
    end.

Define fromSeparatedBinary l := map fromBinary (splitOn 2 l).

Define rotateOnto l1 l2 :=
    match l2 with
    case x :: xs => (l1 @ [x], xs @ [x])
    end.

Define normalizeOstrowski prefix cycle :=
    if isEmpty prefix then
        uncurry normalizeOstrowski (rotateOnto prefix cycle)
    else if (last prefix = 2) & (last cycle = 2) then (prefix, cycle)
    else uncurry normalizeOstrowski (rotateOnto prefix cycle) .

// We want the prefix to end in 2 so everything is nice
Define ostrowskiStr prefix cycle :=
    match normalizeOstrowski prefix cycle with
    // Take tail because all strings start with "2..." (i.e., an empty number), which we ignore because it's uninteresting (and shouldn't actually matter)
    case (newPrefix, newCycle) => concatenate (tail (fromSeparatedBinary newPrefix)) ^ "(" ^ concatenate (fromSeparatedBinary newCycle) ^ ")^ω"
    end.

Define ostrowskiFormat var reps :=
    match reps with
    case [(prefix1, cycle1), (prefix2, cycle2)] =>
        (var, ostrowskiStr (fromBase3 prefix1 prefix2) (fromBase3 cycle1 cycle2))
    end.

bco_valid(a, x) := bco_lsd_valid(a, x) & bco_finite_rep(x)
bco_valid2(a, x, y) := bco_valid(a, x) & bco_valid(a, y)
bco_valid3(a, x, y, z) := bco_valid2(a, x, y) & bco_valid(a, z)

bco_eq(x, y) := bco_leq(x, y) & bco_leq(y, x)

bco_zero(z) := exists a. bco_valid(a,z) & forall y. bco_valid(a,y) => bco_leq(z,y)
bco_succ(a, x, y) := bco_valid2(a, x, y) & bco_leq(x, y) & (!bco_eq(x, y)) & forall z. bco_valid(a,z) => (bco_leq(z,x) | bco_leq(y,z))

bco_succ_unique() := forall a. forall x. forall y. forall z. (bco_succ(a,x,y) & bco_succ(a,x,z)) => bco_eq(y,z)
#assert_prop(true, bco_succ_unique)

bco_adder_total() := forall a. forall x. forall y. bco_valid2(a,x,y) => exists z. bco_valid(a,z) & bco_adder(a,x,y,z)
#assert_prop(true, bco_adder_total)

test_bco_adder_base_case() := forall a. forall x. forall y. forall z. (bco_zero(x) & bco_valid3(a, x, y, z)) => (bco_adder(a,x,y,z) <=> bco_eq(y,z))
#assert_prop(true, test_bco_adder_base_case)
test_bco_adder_inductive_case() := forall a. forall x,y,z. bco_valid3(a,x,y,z) => forall u,v. (bco_succ(a,u,x) & bco_succ(a,v,z)) => (bco_adder(a,x,y,z) <=> bco_adder(a,u,y,v))
#assert_prop(true, test_bco_adder_inductive_case)

test_bco_pred() := forall a, x. bco_valid(a,x) => (bco_zero(x) | (exists u. bco_succ(a,u,x)))
#assert_prop(true, test_bco_pred)

test_bco_adder_not_zero() := forall a,x,y,z. (bco_adder(a,x,y,z) & bco_zero(z)) => bco_zero(x)
#assert_prop(true, test_bco_adder_not_zero)

// This proves that bco_adder is commutative.
test_bco_adder_commutative() := forall a,x,y,z. bco_adder(a,x,y,z) <=> bco_adder(a,y,x,z)
#assert_prop(true, test_bco_adder_commutative)

// This proves that bco_adder is associative.
test_bco_adder_not_associative_implies() := exists a,x,y,z,w. bco_valid3(a,x,y,z) & bco_valid(a,w) & !(exists u. bco_adder(a,x,y,u) & bco_adder(a,u,z,w)) & (exists v. bco_adder(a,y,z,v) & bco_adder(a,x,v,w))
#assert_prop(false, test_bco_adder_not_associative_implies)
test_bco_adder_not_associative_implied_by() := exists a,x,y,z,w. bco_valid3(a,x,y,z) & bco_valid(a,w) & (exists u. bco_adder(a,x,y,u) & bco_adder(a,u,z,w)) & !(exists v. bco_adder(a,y,z,v) & bco_adder(a,x,v,w))
#assert_prop(false, test_bco_adder_not_associative_implied_by)

// This proves that if x = y, there is always a z such that x + z = y, and this z is equal to zero as we expect.
test_bco_adder_identity() := forall a,x,y. (bco_valid2(a,x,y) & bco_eq(x,y)) => exists z. bco_adder(a,x,z,y) & bco_zero(z)
#assert_prop(true, test_bco_adder_identity)

// This proves that there is only one valid zero representation for a given base. Together with the above, this proves the existence of an identity (because it ensures that “zero” is the same element regardless of what we’re adding it to).
test_bco_zero_unique() := forall a. forall x. forall y. (bco_valid2(a,x,y) & bco_zero(x) & bco_zero(y)) => bco_eq(x,y)
#assert_prop(true, test_bco_zero_unique)

// This proves that <= is transitive. Antisymmetry and reflexivity follow immediately from the definition of bco_eq, so it suffices to observe that bco_eq works properly by examining its diagram.
test_bco_leq_trans() := forall x. forall y. forall z. (bco_valid3(a,x,y,z) & bco_leq(x,y) & bco_leq(y,z)) => bco_leq(x,z)
#assert_prop(true, test_bco_leq_trans)

// All the same, let's prove them anyway:
x is possibly_valid := exists a. bco_valid(a, x)
Execute equivalenceRelationCheck bco_eq possibly_valid.

// This proves that <= is a total order as opposed to a partial order.
test_bco_leq_total() := forall a. forall x. forall y. bco_valid2(a,x,y) => (bco_leq(x,y) | bco_leq(y,x))
#assert_prop(true, test_bco_leq_total)

// This proves that x <= y iff x + z <= y + z.
test_bco_adder_order_comp() := forall a. forall x. forall y. forall z. forall u. forall v. (bco_valid3(a,x,y,z) & bco_valid2(a,u,v) & bco_adder(a,x,z,u) & bco_adder(a,y,z,v)) => (bco_leq(x, y) <=> bco_leq(u, v))
#assert_prop(true, test_bco_adder_order_comp)

// This proves that x <= y is equivalent to the existence of z such that x + z = y.
test_bco_adder_order_def() := forall a. forall x. forall y. bco_valid2(a,x,y) => (bco_leq(x,y) <=> exists z. bco_adder(a,x,z,y))
#assert_prop(true, test_bco_adder_order_def)

