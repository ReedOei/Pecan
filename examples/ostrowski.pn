#load("ostrowski/add_2.txt", "pecan", add2(alpha, a, b, c))
#load("ostrowski/recog_2.txt", "pecan", recog2(alpha, x))
#load("ostrowski/all_ones_2.txt", "pecan", all_ones2(a))
#load("sturmian2.txt", "pecan", sturmian(n))

x is ostrowski(a) := x is finite_num & recog2(a, x)

#type(ostrowski(a), {
    "adder": add2(a, any, any, any),
    "less": lt2(any, any)
})

x is zeckendorf := exists alpha is all_ones2. x is ostrowski(alpha)
zeck_add(a, b, c) := exists alpha is all_ones2. add2(alpha, a, b, c)

#type(zeckendorf, {
    "adder": zeck_add(any, any, any),
    "less": lt2(any, any)
})

i, j, k, n are zeckendorf

// These tests are relevant because they use zeckendorf, rather than binary, as we do test_arith.pn
add_comm() := forall i. forall j. i + j = j + i
#assert_prop(true, add_comm)

zero_add_refl() := forall i. i + 0 = i
#assert_prop(true, zero_add_refl)

add_assoc_const() := forall k. k + (1 + 1) = (k + 1) + 1
#assert_prop(true, add_assoc_const)

add_assoc() := forall i. forall j. forall k. exists jk is zeckendorf. jk = j + k & exists ij is zeckendorf. ij = i + j & i + jk = ij + k
#assert_prop(true, add_assoc)

// The Fibonacci word (i.e., characteristic Sturmian word with slope = 1/phi)
F(n) := sturmian(n)

// TODO: Make this nicer
square(i, n) := i is zeckendorf & n is zeckendorf & n > 0 & !(exists k. k < n & (exists ik is zeckendorf. ik = i + k & exists ikn is zeckendorf. ikn = ik + n & ((F(ik) & !F(ikn)) | ((!F(ik)) & F(ikn)))))
squares_exist() := exists i. exists n. square(i, n)
#assert_prop(true, squares_exist)

cube(i, n) := square(i, n) & square(i + n, n)
cubes_exist() := exists i. exists n. cube(i, n)
#assert_prop(true, cubes_exist)

fourth_power(i, n) := square(i, n) & exists in is zeckendorf. in = i + n & square(in, n) & square(in + n, n)
fourth_power_exist() := exists i. exists n. fourth_power(i, n)
#assert_prop(false, fourth_power_exist)

