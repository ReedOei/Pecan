Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 2")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                         addTransition
                        (addTransition innerAut (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 0"))
                                                (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 2"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := finalAut }.

Define qseq q2 q1 cf :=
    match cf with
    case [] => [q2,q1]
    case a :: as => q2 :: qseq q1 (a * q1 + q2) as
    end.

// we run with 0 1 and not 1 0 since q_(-2) = 1, q(-1) = 0, and q(0) = 1 since a0 = 1 and we only care about q1,q2,etc.
Define q cf := tail (qseq 0 1 cf) .

Define makeSum var n :=
    if n < 0 then let temp := makeSum var (-n) in { -temp }
    else if n = 0 then { 0 }
    else if n = 1 then { var }
    else let rest := makeSum var (n - 1) in { rest + var } .

Define binToDec a :=
    match a with
    case [] => 0
    case x :: xs => if x = "1" then 1 + 2* (binToDec xs) else 2 * (binToDec xs)
    end.

// #import("../SturmianWords/ostrowski_defs.pn")

// TODO: Currently requires some manual repetition of a (unfortunately, unlike Haskell, Praline doesn't do infinite lists)
// TODO: Make specific numeration system for the alpha using our general automata/the quadratic irrational representation.

#import("../SturmianWords/ostrowski_defs.pn")

Define makeGAlpha k as :=
    let shiftBy := sum (map strLength (take k as)) + k in
    let aNums := map binToDec (map reverse (map toChars as)) in
    let $SHIFT := "shift_" ^ (toString shiftBy) in 
    let qk := idx(q aNums) k in
    let qkm1 := idx(q aNums) (k-1) in 
    let qkx := makeSum "x" qk in 
    let qkm1y := makeSum "y" qkm1 in do
    makeShift 3 shiftBy;
    emit { g_alpha(a, x is ostrowski(a), y is ostrowski(a)) := @no_simplify[exists z is ostrowski(a). $SHIFT(x,z) & qkx + qkm1y = z] };
    emit { #save_aut("test.aut", g_alpha) };
    emit { #save_aut("shift.aut", $SHIFT) };
    .

Execute makeGAlpha 1 ["1"] .
