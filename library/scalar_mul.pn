#import("../SturmianWords/ostrowski_defs.pn")
#load("./automata/ostrowski/f_alpha_lt.txt", "walnut", f_alpha_lt(x,y))

// Make states for shift automaton
Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

// Make initial state in shift automaton
Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 2")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                         addTransition
                        (addTransition innerAut (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 0"))
                                                (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 2"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

// Makes actual shift automaton
Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let shiftName := "shift_" ^ toString k ^ ".aut" in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := @postprocess[ finalAut ]};
    emit { #save_aut(shiftName, $SHIFT) };
    .



// Make states of quadratic alpha recognization automata
Define makeAlphaStates as :=
    let nums := ( toChars ( intercalate "2" as ) ) @ ["2"]  in
    foldl ( \acc x => head acc ^ x :: acc  ) [head nums] (tail nums) .

// Makes transitions between states to ensure the alpha is the desired quadratic alpha
Define mkAlphaTransitions sts aut :=
    match sts with
    case [a] => aut
    case x :: xs => mkAlphaTransitions xs (addTransition aut (head xs) x (last (toChars x)))
    end.

// Make automata to recognize quadratic alpha 0 <= a < 1 which are immediately repeating
Define makeAlpha as :=
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let alphaName := "alpha-" ^ intercalate "-" as ^ ".aut" in
    let states := makeAlphaStates as in
    let baseAut := withStates (mkAut ["a"] [3]) ( ("init", true) :: map (\x => (x,true) ) states ) in
    let finalAut := buildAut (addTransition (mkAlphaTransitions (last states :: states) baseAut) "init" (head states) "2") in do
    emit { $ALPHA(a) := finalAut };
    emit { #save_aut(alphaName, $ALPHA) };
    .
    


// Definition of the qi's - denominators of the continued fraction representation of a
Define qseq q2 q1 cf :=
    match cf with
    case [] => [q2,q1]
    case a :: as => q2 :: qseq q1 (a * q1 + q2) as
    end.

// We run with 0 1 and not 1 0 since q_(-2) = 1, q(-1) = 0, and q(0) = 1 since a0 = 1 and we only care about q1,q2,etc.
Define q cf := tail (qseq 0 1 cf) .

// Simple automata to recognize if n*x = y, uses binary addition to do O(log n) operations
Define makeTimesN n as :=
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let $TIMESN := "times" ^ toString n ^ "_" intercalate "-" as in
    let timesNName := "times-" ^ toString n ^ "_" intercalate "-" as ^  ".aut" in do
    makeAlpha as; 
    emit { $TIMESN(x is ostrowski(a), y is ostrowski(a) ) := exists a is $ALPHA. bco_eq(n*x, y) };
    emit { #save_aut( timesNName, $TIMESN ) };
    .
 
// Transform a binary number with least significant bit first into its decimal counterpart
Define binToDec a :=
    match a with
    case [] => 0
    case x :: xs => if x = "1" then 1 + 2* (binToDec xs) else 2 * (binToDec xs)
    end.

// Make the powers of 2 < n
Define make2Powers n acc :=
    if acc > n then []
    else acc :: ( make2Powers n (2*acc) ).

Define decToBinH n arr :=
    match arr with
    case [] => []
    case x :: xs => if n - x >= 0 then "1" :: (decToBinH (n-x) xs) else "0" :: (decToBinH n xs)
    end.

// Turn a decimal into least significant first binary representation
Define decToBin n := reverse (decToBinH n (reverse (make2Powers n 1) )).


// Make g_alpha function as defined in https://arxiv.org/pdf/1805.03624.pdf
// The constants qk, qkm1 can be shown to be the correct ones inductively
// 
// To use:
// as = ["n1", "n2", ... ] where the desired infinite fraction is 1/(n1+1/(n2+...)) which cycles through the coefficients. Each ni is written as a least significant digit first binary number.
Define makeGAlpha as :=
    let k := length as in
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in 
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let shiftBy := sum (map strLength (take k as)) + k in
    let gAlphaName := "g_alpha-" ^ intercalate "-" as ^ ".aut" in
    let aNums := map binToDec (map toChars as) in
    let $SHIFT := "shift_" ^ (toString shiftBy) in 
    let qk := idx(q aNums) k in
    let qkm1 := idx(q aNums) (k-1) in 
    makeShift 3 shiftBy;
    makeAlpha as;
    emit { $GALPHA(x is ostrowski(a), y is ostrowski(a)) := @postprocess[ exists a is $ALPHA. exists sum is ostrowski(a). $SHIFT(x, sum) /\ qk * x + qkm1 * y = sum ] };
    emit { #save_aut(gAlphaName, $GALPHA) };
    .

// Make a function which determines whether x+ay < p+aq for x,y,p,q integers and a a quadratic irrational. From above paper.
// Often too slow to be created and too large to use for even simple as, so in practice it's better to take one or more of x,y,p,q to be zero and rewrite formula accordingly noting that g_alpha(0) = 0.
Define makeAlphaMonicLT as :=
    let ltName := "alpha_monic_lt-" ^ intercalate "-" as ^ ".aut" in
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in do
    makeGAlpha as;
    emit {
        alpha_monic_lt(x is ostrowski(a), y is ostrowski(a), p is ostrowski(a), q is ostrowski(a)) := @no_simplify [ exists a is $ALPHA. exists gy is ostrowski(a). $GALPHA(y,gy)  /\ exists xgy is ostrowski(a). x+gy = xgy /\ exists gq is ostrowski(a). $GALPHA(q,gq) /\ exists pgq is ostrowski(a). p+gq = pgq /\ (xgy < pgq \/ ( bco_eq(xgy, pgq ) /\ f_alpha_lt(y, q) ) ) ]
        };
    emit { #save_aut(ltName , alpha_monic_lt) };
    .
