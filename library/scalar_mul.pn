Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 2")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                         addTransition
                        (addTransition innerAut (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 0"))
                                                (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 2"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let shiftName := "shift_" ^ toString k ^ ".aut" in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := finalAut };
    emit { #save_aut(shiftName, $SHIFT) };
    .

Define qseq q2 q1 cf :=
    match cf with
    case [] => [q2,q1]
    case a :: as => q2 :: qseq q1 (a * q1 + q2) as
    end.

// we run with 0 1 and not 1 0 since q_(-2) = 1, q(-1) = 0, and q(0) = 1 since a0 = 1 and we only care about q1,q2,etc.
Define q cf := tail (qseq 0 1 cf) .

Define makeSum var n :=
    if n < 0 then let temp := makeSum var (-n) in { -temp }
    else if n = 0 then { 0 }
    else if n = 1 then { var }
    else let rest := makeSum var (n - 1) in { rest + var } .

Define binToDec a :=
    match a with
    case [] => 0
    case x :: xs => if x = "1" then 1 + 2* (binToDec xs) else 2 * (binToDec xs)
    end.

#import("../SturmianWords/ostrowski_defs.pn")
#load("./automata/ostrowski/f_alpha_lt.txt", "walnut", f_alpha_lt(x,y))

Define makeGAlpha k as :=
    let shiftBy := sum (map strLength (take k as)) + k in
    let gAlphaName := "g_alpha-" ^ intercalate "-" as ^ ".aut" in
    let aNums := map binToDec (map toChars as) in
    let $SHIFT := "shift_" ^ (toString shiftBy) in 
    let qk := idx(q aNums) k in
    let qkm1 := idx(q aNums) (k-1) in 
    let qkx := makeSum "x" qk in 
    let qkm1y := makeSum "y" qkm1 in do
    makeShift 3 shiftBy;
    emit { g_alpha(a, x is ostrowski(a), y is ostrowski(a)) := @no_simplify [ $SHIFT(x, qkx + qkm1y) ] };
    emit { #save_aut(gAlphaName, g_alpha) };
    .

Define makeAlphaMonicLT k as :=
    let ltName := "alpha_monic_lt-" ^ intercalate "-" as ^ ".aut" in do
    makeGAlpha k as;
    emit {
        alpha_monic_lt(a, x is ostrowski(a), y is ostrowski(a), p is ostrowski(a), q is ostrowski(a)) :=
            @no_simplify [
                exists g_y is ostrowski(a). exists g_q is ostrowski(a).
                g_alpha(a, y, g_y) /\ g_alpha(a, q, g_q) /\ (x + g_y < p + g_q \/ (bco_eq(x + g_y, p + g_q) /\ f_alpha_lt(y, q)))
            ]
    };
    emit { #save_aut(ltName , alpha_monic_lt) };
    .
