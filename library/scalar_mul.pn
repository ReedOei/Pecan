Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 2")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                         addTransition
                        (addTransition innerAut (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 0"))
                                                (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 2"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let shiftName := "shift_" ^ toString k ^ ".aut" in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := @postprocess[ finalAut ]};
    emit { #save_aut(shiftName, $SHIFT) };
    .

Define qseq q2 q1 cf :=
    match cf with
    case [] => [q2,q1]
    case a :: as => q2 :: qseq q1 (a * q1 + q2) as
    end.

// we run with 0 1 and not 1 0 since q_(-2) = 1, q(-1) = 0, and q(0) = 1 since a0 = 1 and we only care about q1,q2,etc.
Define q cf := tail (qseq 0 1 cf) .

Define makeSum var a n :=
    if n = 0 then let v0 := var ^ "0" in { exists v0. ostrowski_zero(a, v0) }
    else if n = 1 then let v1 := var ^ "1" in {  exists v1 is ostrowski(a). bco_eq(x,v1) }
    else if n = 2 then let v2 := var ^ "2" in {  @postprocess [ exists v2 is ostrowski(a). bco_adder(a, var, var,v2) ] }
    else let rest := makeSum var a (n - 1) in
         let vn := var ^ (toString n) in 
         let vnm1 := var ^ (toString (n-1)) in
         { @postprocess [  rest /\ (  @postprocess [ exists vn is ostrowski(a).  bco_adder(a, vnm1, var, vn) ] ) ] } .

Define binToDec a :=
    match a with
    case [] => 0
    case x :: xs => if x = "1" then 1 + 2* (binToDec xs) else 2 * (binToDec xs)
    end.

#import("../SturmianWords/ostrowski_defs.pn")
#load("./automata/ostrowski/f_alpha_lt.txt", "walnut", f_alpha_lt(x,y))

Define makeGAlpha k as :=
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in 
    let shiftBy := sum (map strLength (take k as)) + k in
    let gAlphaName := "g_alpha-" ^ intercalate "-" as ^ ".aut" in
    let aNums := map binToDec (map toChars as) in
    let $SHIFT := "shift_" ^ (toString shiftBy) in 
    let qk := idx(q aNums) k in
    let qkm1 := idx(q aNums) (k-1) in 
    let qkx := if qk = 1 then "x" else "x" ^ (toString qk) in 
    let qkm1y := if qkm1 = 1 then "y" else "y" ^ (toString qkm1) in do
    let mulx := makeSum "x" "a" qk in
    let muly := makeSum "y" "a" qkm1 in do
    makeShift 3 shiftBy;
    emit { $GALPHA(a, x is ostrowski(a), y is ostrowski(a)) :=  @postprocess [ @postprocess[ mulx ] /\ @postprocess[ muly ] /\ @postprocess [ exists sum. bco_adder(a,qkx,qkm1y,sum) /\ $SHIFT(x, sum ) ] ] };
    emit { #save_aut(gAlphaName, $GALPHA) };
    .

Define makeAlphaMonicLT k as :=
    let ltName := "alpha_monic_lt-" ^ intercalate "-" as ^ ".aut" in
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in do
    makeGAlpha k as;
    emit {
        alpha_monic_lt(a, c is ostrowski(a), d is ostrowski(a), p is ostrowski(a), q is ostrowski(a)) := @postprocess [ @postprocess [ exists gd is ostrowski(a). exists gq is ostrowski(a). $GALPHA(a, q, gq) /\ $GALPHA(a, d, gd) ] /\ @postprocess[ (c + gd < p + gq \/ ( bco_eq(c + gd, p + gq ) /\ f_alpha_lt(d, q) ) ) ] ]
        };
    emit { #save_aut(ltName , alpha_monic_lt) };
    .
