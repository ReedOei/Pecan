Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 0")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (curState @ [sym]))
                                               (sym ^ " 0"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := finalAut };
    emit { #save_aut("test.aut", $SHIFT) };
    emit { #save_aut_img("test.svg", $SHIFT) }.

// Define makeGAlpha k a :=
//     let $SHIFT := "shift_" ^ toString k in
//     let gAlphaName := in do
//     emit { g_alpha(x, y) := $SHIFT(x) + y*d = x } .

