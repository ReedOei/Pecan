#import("../SturmianWords/ostrowski_defs.pn")
#load("./automata/ostrowski/f_alpha_lt.txt", "walnut", f_alpha_lt(x,y))

Define mkShiftStates alphabet k :=
    if k = 1 then map (\a => (a, true)) alphabet
    else mkShiftStates alphabet (k - 1)
         @
         map (\sts => (intercalate "," sts, true)) (cart_prod (replicate k alphabet)) .

Define mkShiftInit alphabet aut :=
    foldl (\curAut sym => addTransition curAut "init" sym (sym ^ " 2")) aut alphabet.

// The difference between mkShiftPrefix and mkShiftTransitions is that mkShiftTransitions considers states with *at most* k symbols (we truncate with tail),
// whereas mkShiftPrefix will just add the symbol to the end of the current state.
Define mkShiftPrefix alphabet k aut :=
    if k = 0 then aut
    else mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                         addTransition
                        (addTransition innerAut (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 0"))
                                                (intercalate "," curState)
                                                (intercalate "," (curState @ [sym]))
                                                (sym ^ " 2"))
                      curAut alphabet)
              aut (cart_prod (replicate k alphabet))).

Define mkShiftTransitions alphabet k aut :=
    mkShiftPrefix alphabet (k - 1) (
        foldl (\curAut curState =>
                foldl (\innerAut sym =>
                        addTransition innerAut (intercalate "," curState)
                                               (intercalate "," (tail curState @ [sym]))
                                               (sym ^ " " ^ head curState))
                      curAut alphabet)
               aut (cart_prod (replicate k alphabet))).

Define makeShift base k :=
    let $SHIFT := "shift_" ^ toString k in
    let shiftName := "shift_" ^ toString k ^ ".aut" in
    let alphabet := map toString [0..base - 1] in
    let states := ("init", true) :: mkShiftStates alphabet k in
    let baseAut := withStates (mkAut ["n", "m"] [base, base]) states in
    let finalAut := buildAut (mkShiftTransitions alphabet k (mkShiftInit alphabet baseAut)) in do

    emit { $SHIFT(n, m) := @postprocess[ finalAut ]};
    emit { #save_aut(shiftName, $SHIFT) };
    .





Define makeAlphaStates as :=
    let nums := ( toChars ( intercalate "2" as ) ) @ ["2"]  in
    foldl ( \acc x => head acc ^ x :: acc  ) [head nums] (tail nums) .

Define mkAlphaTransitions sts aut :=
    match sts with
    case [a] => aut
    case x :: xs => mkAlphaTransitions xs (addTransition aut (head xs) x (last (toChars x)))
    end.


Define makeAlpha as :=
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let alphaName := "alpha-" ^ intercalate "-" as ^ ".aut" in
    let states := makeAlphaStates as in
    let baseAut := withStates (mkAut ["a"] [3]) ( ("init", true) :: map (\x => (x,true) ) states ) in
    let finalAut := buildAut (addTransition (mkAlphaTransitions (last states :: states) baseAut) "init" (head states) "2") in do

    emit { $ALPHA(a) := finalAut };
    emit { #save_aut(alphaName, $ALPHA) };
    .
    








Define qseq q2 q1 cf :=
    match cf with
    case [] => [q2,q1]
    case a :: as => q2 :: qseq q1 (a * q1 + q2) as
    end.

// we run with 0 1 and not 1 0 since q_(-2) = 1, q(-1) = 0, and q(0) = 1 since a0 = 1 and we only care about q1,q2,etc.
Define q cf := tail (qseq 0 1 cf) .

Define makeSumNew var a n :=
    if n = 0 then let v0 := var ^ "0" in { exists v0. ostrowski_zero(a, v0) }
    else if n = 1 then let v1 := var ^ "1" in {  exists v1 is ostrowski(a). bco_eq(x,v1) }
    else if n = 2 then let v2 := var ^ "2" in {  exists v2 is ostrowski(a). bco_adder(a, var, var,v2) }
    else let rest := makeSum var a (n - 1) in
         let vn := var ^ (toString n) in 
         let vnm1 := var ^ (toString (n-1)) in
         { rest /\ ( exists vn is ostrowski(a).  bco_adder(a, vnm1, var, vn) ) } .


Define makeSum var n :=
    if n < 0 then let temp := makeSum var (-n) in { -temp }
    else if n = 0 then { 0 }
    else if n = 1 then { var }
    else let rest := makeSum var (n - 1) in { rest + var } .

Define makeTimesN n as :=
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let ntx := makeSum "x" n in
    let $TIMESN := "times-" ^ toString n in
    let timesNName := "times-" ^ toString n ^ ".aut" in do
    makeAlpha as; 
    emit { $TIMESN(x is ostrowski(a), y is ostrowski(a) ) := exists a is $ALPHA. bco_eq(ntx, y) };
    emit { #save_aut( timesNName, $TIMESN ) };
    .

Define binToDec a :=
    match a with
    case [] => 0
    case x :: xs => if x = "1" then 1 + 2* (binToDec xs) else 2 * (binToDec xs)
    end.


Define makeGAlpha as :=
    let k := length as in
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in 
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let shiftBy := sum (map strLength (take k as)) + k in
    let gAlphaName := "g_alpha-" ^ intercalate "-" as ^ ".aut" in
    let aNums := map binToDec (map toChars as) in
    let $SHIFT := "shift_" ^ (toString shiftBy) in 
    let qk := idx(q aNums) k in
    let qkm1 := idx(q aNums) (k-1) in 
    let qkx := makeSum "x" qk in
    let qkm1y := makeSum "y" qkm1 in do
    makeShift 3 shiftBy;
    makeAlpha as;
    emit { $GALPHA(x is ostrowski(a), y is ostrowski(a)) := @no_simplify[ exists a is $ALPHA. exists sum is ostrowski(a). $SHIFT(x, sum) /\ qkx + qkm1y = sum ] };
    emit { #save_aut(gAlphaName, $GALPHA) };
    .

Define makeAlphaMonicLT as :=
    let ltName := "alpha_monic_lt-" ^ intercalate "-" as ^ ".aut" in
    let $ALPHA := "alpha-" ^ intercalate "-" as in
    let $GALPHA := "g_alpha-" ^ intercalate "-" as in do
    makeGAlpha as;
    emit {
        alpha_monic_lt(x is ostrowski(a), y is ostrowski(a), p is ostrowski(a), q is ostrowski(a)) := @no_simplify [ exists a is $ALPHA. exists gy is ostrowski(a). $GALPHA(y,gy)  /\ exists xgy is ostrowski(a). x+gy = xgy /\ exists gq is ostrowski(a). $GALPHA(q,gq) /\ exists pgq is ostrowski(a). p+gq = pgq /\ (xgy < pgq \/ ( bco_eq(xgy, pgq ) /\ f_alpha_lt(y, q) ) ) ]
        };
    emit { #save_aut(ltName , alpha_monic_lt) };
    .
