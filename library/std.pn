#load("bin_add.aut", "hoa", bin_add(a, b, c))
#load("bin_less.aut", "hoa", bin_less(a, b))
#load("odd_ones.aut", "hoa", odd_ones(a))

finite_num(x) := "F(G(!x))"
zero(x) := "G(!x)"

x is any := true
x is nat := finite_num(x)
// binary is, for the moment, a synonym for nat; eventually we may decouple the two
x is binary := finite_num(x)

Restrict x is binary.
bin_even(x) := x is binary & exists y is binary. x = 2*y
bin_odd(x) := x is binary & ¬bin_even(x)
#forget(x)

bin_one(x is binary) := x > 0 & forall b is binary. b > 0 => (x <= b)

default_equal(x, y) := "G((x -> y) & (y -> x))"

// Establish some default adders and such
#context("adder", "bin_add")
#context("less", "bin_less")
#context("one", "bin_one")
#context("equal", "default_equal")

#type(nat, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "even": bin_even(any),
    "equal": default_equal(any, any),
    "odd": bin_odd(any)
})

#type(binary, {
    "adder": bin_add(any, any, any),
    "less": bin_less(any, any),
    "one": bin_one(any),
    "equal": default_equal(any, any),
    "even": bin_even(any),
    "odd": bin_odd(any)
})

Define enumFromTo low high :=
    if low > high then
        []
    else
        low :: enumFromTo (low + 1) high .

Define flip f a b := f b a.

Define isEmpty l :=
    match l with
    case [] -> true
    case x :: xs -> false
    end.

Define foldl f init l :=
    match l with
    case [] -> init
    case x :: xs -> foldl f (f init x) xs
    end.

Define foldr f init l :=
    match l with
    case [] -> init
    case x :: xs -> f x (foldr f init xs)
    end.

Define length := foldl (\cur _ -> cur + 1) 0.
Define map f := foldr (\x rest -> f x :: rest) [].
Define filter f := foldr (\x rest -> if f x then x :: rest else rest) [].

Define id x := x.

Define a & b := if a then b else false.
Define a | b := if a then true else b.

Define compose f g x := f (g x).
Define f ∘ g := compose f g.

Define x :: xs := cons x xs.

Define bimap f g pair :=
    match pair with
    case (a, b) -> (f a, g b)
    end.

Define lmap f := bimap f id.
Define rmap g := bimap id g.

Define split n l :=
    if n = 0 then ([], l)
    else match l with
         case [] -> ([], l)
         case x :: xs -> lmap (\before -> x :: before) (split (n - 1) xs)
         end.

Define take n l := fst (split n l).
Define drop n l := snd (split n l).

Define head l :=
    match l with
    case x :: _ -> x
    end.

Define tail l :=
    match l with
    case _ :: xs -> xs
    end.

Define find f l :=
    match l with
    case [] -> []
    case x :: xs -> if f x then [x] else find f xs
    end.

Define lookup key assocs :=
    match find (\kv -> fst kv = key) assocs with
    case [] -> []
    case [x] -> snd x
    end.

Define delete key := filter (\kv -> fst kv != key).

Define concatenate := foldl (\a b -> a ^ toString b) "".

Define boolToInt b := if b then 1 else 0.
Define checkToInt := boolToInt ∘ check.
Define showWord word := concatenate ∘ map (\i -> checkToInt { word(i) }).

Define wordToBinary inputWord :=
    match inputWord with
    case (var, (prefix, cycle)) -> (var, (map boolToInt prefix, map boolToInt cycle))
    end.

// Note this function converts from **LSD** binary
Define fromBinary := foldr (\a b -> a + 2*b) 0.

Define stdFormat var prefix cycle := (var, concatenate prefix ^ "(" ^ concatenate cycle ^ ")^w").

Define natFormat var prefix cycle :=
    if cycle = [0] then
        (var, if isEmpty prefix then "0" else toString (fromBinary prefix))
    else
        stdFormat var prefix cycle ^ " (NOT A VALID NATURAL NUMBER)"
    .
Define intFormat var prefix cycle :=
    if cycle = [0] then
        (var,
            if isEmpty prefix then "0"
            else match prefix with
                 case 0 :: digits -> toString (fromBinary digits)
                 case 1 :: digits -> "-" ^ toString (fromBinary digits)
                 end
        )
    else
        stdFormat var prefix cycle ^ " (NOT A VALID INTEGER)"
    .

Define runFormat format inputWord :=
    match inputWord with
    case (var, (prefix, cycle)) -> format var prefix cycle
    end.

Define example format t := map (runFormat format ∘ wordToBinary) (acceptingWord t).

Define graphPoint format F x :=
    let y be { F(x, y) } in
    (x, lookup "y" (example format y)).
Define graph format F := map (graphPoint format F).

Define fst pair :=
    match pair with
    case (a, b) -> a
    end.

Define snd pair :=
    match pair with
    case (a, b) -> b
    end.

Define theoremCheck ID BODY := do
    emit { ID() := BODY };
    emit { #assert_prop(true, ID) }
    .

Define partialOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let IRREFL_ID := R ^ "_irrefl" in
    let ANTISYM_ID := R ^ "_antisym" in
    let TRANS_ID := R ^ "_trans" in do
        theoremCheck IRREFL_ID { forall VAR1 is T. !R(VAR1, VAR1) };
        theoremCheck ANTISYM_ID { forall VAR1 is T. forall VAR2 is T. if R(VAR1, VAR2) & R(VAR2, VAR1) then EQ(VAR1, VAR2) };
        theoremCheck TRANS_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if R(VAR1, VAR2) & R(VAR2, VAR3) then R(VAR1, VAR3) }
    .

Define totalOrderCheck R EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let TOTAL_ID := R ^ "_total" in do
        partialOrderCheck R EQ T;
        theoremCheck TOTAL_ID { forall VAR1 is T. forall VAR2 is T. R(VAR1, VAR2) | EQ(VAR1, VAR2) | R(VAR2, VAR1) }
    .

Define equivalenceRelationCheck EQ T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let REFL_ID := EQ ^ "_refl" in
    let SYM_ID := EQ ^ "_sym" in
    let TRANS_ID := EQ ^ "_trans" in do
        theoremCheck REFL_ID { forall VAR1 is T. EQ(VAR1, VAR1) };
        theoremCheck SYM_ID { forall VAR1 is T. forall VAR2 is T. EQ(VAR1, VAR2) <=> EQ(VAR2, VAR1) };
        theoremCheck TRANS_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. if EQ(VAR1, VAR2) & EQ(VAR2, VAR3) then EQ(VAR1, VAR3) }
    .

Define createTypedAdder ADD T :=
    let TYPED_ADDER := freshVar in do
        emit { TYPED_ADDER(x is T, y is T, z is T) := ADD(x, y, z) };
        TYPED_ADDER
    .

Define monoidCheck ADD T :=
    let TYPED_ADDER := createTypedAdder ADD T in
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let VAR3 := freshVar in
    let CLOSED_ID := ADD ^ "_closed" in
    let ASSOC_ID := ADD ^ "_assoc" in
    let ZERO_ID_ID := ADD ^ "_zero_id" in do // Not a typo
        theoremCheck CLOSED_ID { forall VAR1 is T. forall VAR2 is T. exists VAR3 is T. TYPED_ADDER(VAR1, VAR2, VAR3) };
        theoremCheck ASSOC_ID { forall VAR1 is T. forall VAR2 is T. forall VAR3 is T. TYPED_ADDER(VAR1, TYPED_ADDER(VAR2, VAR3)) = TYPED_ADDER(TYPED_ADDER(VAR1, VAR2), VAR3) };
        theoremCheck ZERO_ID_ID { forall VAR1 is T. TYPED_ADDER(VAR1, 0, VAR1) & TYPED_ADDER(0, VAR1, VAR1) }
    .

Define groupCheck ADD T :=
    let TYPED_ADDER := createTypedAdder ADD T in
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let INVERSE_ID := ADD ^ "_inverse" in do
        monoidCheck ADD T;
        theoremCheck INVERSE_ID { forall VAR1 is T. exists VAR2 is T. TYPED_ADDER(VAR1, VAR2, 0) }
    .

Define abelianGroupCheck ADD T :=
    let VAR1 := freshVar in
    let VAR2 := freshVar in
    let COMM_ID := ADD ^ "_comm" in do
        groupCheck ADD T;
        theoremCheck COMM_ID { forall VAR1 is T. forall VAR2 is T. ADD(VAR1, VAR2) = ADD(VAR2, VAR1) }
    .

