Long:
- Convert all operators to predicate calls after the last stage of optimizations
    - Long because this may introduce new issues (including performance issues)

Medium:
- Try doing some of the fundamental automata operations (e.g., project, substitute) in C++ to speed things up a little bit
    - Lots of repeated calls into buddy/spot from python probably slow us down a lot on big automata
    - DONE FOR PROJECTION, because it was built-in
    - Should still do for substitution
- Expand calls with expressions for arguments before interpretation so the optimizer can work on them
- Improve optimization so that we don't need to do what we do in test_bounded_ostrowski_2
- Improve CSE optimization so that we use `forall` or `exists` to reduce the number of complements, when valid.
    For example, we should optimize

    forall x. x + (y + z) = k

    as

    forall x. forall yz. y + z = yz => x + yz = k

    instead of

    forall x. exists yz. y + z = yz & x + yz = k

    when these two statements are equivalent (probably as long as addition is real function (i.e., with unique output)).

- Add new __repr__ functions that do a more standard repr (e.g., Class(field_1, field_2, ...)) that turn on with debug 2
- See if we can reduce the usage of the `type` function...(either replace with isinstance or just remove altogether)
- Combine unification code for looking up dynamic calls (in ir/prog.py and doing typechecking)
- When we cache variable representations (in class Program's var_map), we need to make sure that we don't accidentally cahce two different represenations of the same constnat, because it may be encoded differently. To be safe, probably just don't cache constants aps at all?
- Expand the function expressions in typed ir lowering.
- Implement some heuristics for smarter postprocessing?
    - For example, only do High/Deterministic or Small if the automaton is very small
- Add a cache mode to predicates (or maybe an annotation?) so that we can save to disk and reload automatically instead of recomputing without having to save/load manually
- Add the ability to make Praline builtins out of arbitrary Python functions
- Add option to output intermediate results .

Short:
- Add a builtin to Praline that calls the optimizer
- Move SpotFormula out of prog to keep the main program automata/library independent (replace this with a more general "Formula") operation.
- Make all parsing functions in pecan.lang.parser into proper functions (b/c it gives better debug info)
- Make converter warn when you try to use states that don't exist, but just map them to new, empty states
- Allow matching on booleans in Praline. Practically, this is useless (it's just an if expression), but it'd be nice to have for consistency's sake. Although this would let us compile if expressions into match-case expressions, which would simplify other stuff a tad.
- Improve error messages when there is no accepting word.

